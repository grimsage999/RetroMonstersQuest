üö® EMERGENCY: RENDERING PIPELINE RECONSTRUCTION
CRITICAL MISSION: Fix 24-28 FPS ‚Üí 60 FPS Performance
The game is fundamentally broken due to rendering pipeline failures. ALL OTHER DEVELOPMENT MUST STOP until this is resolved. This is blocking everything including Pinterest aesthetic implementation.

üî• PHASE 1: IMMEDIATE RENDERING PIPELINE REBUILD
STEP 1: Emergency Performance Profiling
typescript// IMPLEMENT THIS DIAGNOSTIC CODE IMMEDIATELY:
class PerformanceDiagnostic {
  private frameStart: number = 0;
  private frameTimes: number[] = [];
  
  startFrame() {
    this.frameStart = performance.now();
  }
  
  endFrame(context: string) {
    const frameTime = performance.now() - this.frameStart;
    this.frameTimes.push(frameTime);
    
    if (frameTime > 16.67) {
      console.error(`SLOW FRAME [${context}]: ${frameTime.toFixed(2)}ms`);
    }
    
    // Keep only last 60 frames
    if (this.frameTimes.length > 60) {
      this.frameTimes.shift();
    }
    
    // Report average every 60 frames
    if (this.frameTimes.length === 60) {
      const avgFPS = 1000 / (this.frameTimes.reduce((a, b) => a + b) / 60);
      console.log(`Average FPS: ${avgFPS.toFixed(1)}`);
    }
  }
}

const perfDiag = new PerformanceDiagnostic();
STEP 2: Strip Down Rendering to Bare Minimum
typescript// EMERGENCY RENDERING SIMPLIFICATION:
// Comment out ALL non-essential rendering:
// - Disable particle effects
// - Remove sprite animations temporarily
// - Disable background parallax
// - Remove visual effects
// - Keep only: player sprite, enemy sprites, cookies, basic UI

// Test with minimal render loop:
function emergencyRenderLoop() {
  perfDiag.startFrame();
  
  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Render ONLY essential elements:
  renderPlayer();     // Single static sprite
  renderEnemies();    // Single static sprites
  renderCookies();    // Single static sprites
  renderUI();         // Basic text only
  
  perfDiag.endFrame('minimal');
  requestAnimationFrame(emergencyRenderLoop);
}
STEP 3: Canvas Optimization Emergency Fixes
typescript// APPLY THESE CANVAS OPTIMIZATIONS IMMEDIATELY:
const canvas = document.getElementById('gameCanvas') as HTMLCanvasElement;
const ctx = canvas.getContext('2d')!;

// Critical canvas settings:
ctx.imageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;

// Set canvas to exact pixel dimensions
canvas.style.imageRendering = 'pixelated';
canvas.style.imageRendering = 'crisp-edges';

// Optimize canvas size
canvas.width = 800;
canvas.height = 600;

üõ†Ô∏è PHASE 2: SYSTEMATIC PERFORMANCE HUNTING
STEP 4: Identify Performance Killers
typescript// ADD TIMING TO EVERY MAJOR SYSTEM:
class SystemProfiler {
  static profile<T>(name: string, fn: () => T): T {
    const start = performance.now();
    const result = fn();
    const end = performance.now();
    
    if (end - start > 1) { // Log anything over 1ms
      console.warn(`SLOW OPERATION [${name}]: ${(end - start).toFixed(2)}ms`);
    }
    
    return result;
  }
}

// Profile these systems:
SystemProfiler.profile('collision-detection', () => updateCollisions());
SystemProfiler.profile('sprite-rendering', () => renderSprites());
SystemProfiler.profile('state-update', () => updateGameState());
SystemProfiler.profile('input-processing', () => processInput());
STEP 5: Fix Collision Detection Performance
typescript// OPTIMIZE COLLISION SYSTEM:
class OptimizedCollisionSystem {
  private spatialGrid: Map<string, GameObject[]> = new Map();
  private gridSize = 32; // Optimize based on sprite sizes
  
  updateSpatialGrid() {
    this.spatialGrid.clear();
    
    // Only update grid when objects move significantly
    gameObjects.forEach(obj => {
      if (obj.positionChanged) {
        const gridKey = `${Math.floor(obj.x / this.gridSize)}-${Math.floor(obj.y / this.gridSize)}`;
        if (!this.spatialGrid.has(gridKey)) {
          this.spatialGrid.set(gridKey, []);
        }
        this.spatialGrid.get(gridKey)!.push(obj);
        obj.positionChanged = false;
      }
    });
  }
  
  checkCollisions() {
    // Only check objects in same grid cells
    this.spatialGrid.forEach(objects => {
      if (objects.length > 1) {
        // Check collisions only within this cell
        for (let i = 0; i < objects.length - 1; i++) {
          for (let j = i + 1; j < objects.length; j++) {
            if (this.simpleCollision(objects[i], objects[j])) {
              this.handleCollision(objects[i], objects[j]);
            }
          }
        }
      }
    });
  }
  
  simpleCollision(a: GameObject, b: GameObject): boolean {
    return !(a.x + a.width < b.x || 
             b.x + b.width < a.x || 
             a.y + a.height < b.y || 
             b.y + b.height < a.y);
  }
}
STEP 6: Implement Sprite Batching
typescript// BATCH SPRITE RENDERING:
class SpriteRenderer {
  private spriteCache: Map<string, HTMLImageElement> = new Map();
  private renderQueue: RenderCommand[] = [];
  
  queueSprite(sprite: string, x: number, y: number) {
    this.renderQueue.push({ sprite, x: Math.floor(x), y: Math.floor(y) });
  }
  
  flushRenderQueue() {
    // Sort by sprite type to minimize context switches
    this.renderQueue.sort((a, b) => a.sprite.localeCompare(b.sprite));
    
    let currentSprite = '';
    let currentImage: HTMLImageElement | null = null;
    
    this.renderQueue.forEach(cmd => {
      if (cmd.sprite !== currentSprite) {
        currentSprite = cmd.sprite;
        currentImage = this.spriteCache.get(cmd.sprite) || null;
      }
      
      if (currentImage) {
        ctx.drawImage(currentImage, cmd.x, cmd.y);
      }
    });
    
    this.renderQueue.length = 0; // Clear queue
  }
  
  preloadSprites(spriteUrls: string[]) {
    spriteUrls.forEach(url => {
      const img = new Image();
      img.onload = () => this.spriteCache.set(url, img);
      img.src = url;
    });
  }
}

üéØ PHASE 3: CRITICAL SYSTEM RECONSTRUCTION
STEP 7: Rebuild Game Loop with Performance
typescript// HIGH-PERFORMANCE GAME LOOP:
class GameLoop {
  private lastTime = 0;
  private accumulator = 0;
  private readonly fixedTimeStep = 1000 / 60; // 60 FPS
  private readonly maxFrameTime = 1000 / 30; // Prevent death spiral
  
  private renderer = new SpriteRenderer();
  private collisions = new OptimizedCollisionSystem();
  
  loop(currentTime: number) {
    const frameTime = Math.min(currentTime - this.lastTime, this.maxFrameTime);
    this.lastTime = currentTime;
    this.accumulator += frameTime;
    
    // Fixed timestep updates
    while (this.accumulator >= this.fixedTimeStep) {
      this.update(this.fixedTimeStep);
      this.accumulator -= this.fixedTimeStep;
    }
    
    // Render with interpolation
    const alpha = this.accumulator / this.fixedTimeStep;
    this.render(alpha);
    
    requestAnimationFrame((time) => this.loop(time));
  }
  
  private update(deltaTime: number) {
    SystemProfiler.profile('input', () => this.processInput());
    SystemProfiler.profile('physics', () => this.updatePhysics(deltaTime));
    SystemProfiler.profile('collisions', () => this.collisions.checkCollisions());
    SystemProfiler.profile('game-logic', () => this.updateGameLogic());
  }
  
  private render(alpha: number) {
    perfDiag.startFrame();
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Queue all sprites for batch rendering
    this.queueRenderables(alpha);
    
    // Flush all sprites at once
    this.renderer.flushRenderQueue();
    
    perfDiag.endFrame('render');
  }
}
STEP 8: Asset Loading Optimization
typescript// OPTIMIZED ASSET LOADING:
class AssetManager {
  private loaded = new Map<string, HTMLImageElement>();
  private loading = new Map<string, Promise<HTMLImageElement>>();
  
  async preloadCriticalAssets() {
    const criticalAssets = [
      'cosmo-sprite.png',
      'cia-agent.png', 
      'cookie.png',
      'background-level1.png'
    ];
    
    const promises = criticalAssets.map(asset => this.loadImage(asset));
    await Promise.all(promises);
    
    console.log('Critical assets loaded:', this.loaded.size);
  }
  
  private loadImage(src: string): Promise<HTMLImageElement> {
    if (this.loaded.has(src)) {
      return Promise.resolve(this.loaded.get(src)!);
    }
    
    if (this.loading.has(src)) {
      return this.loading.get(src)!;
    }
    
    const promise = new Promise<HTMLImageElement>((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        this.loaded.set(src, img);
        this.loading.delete(src);
        resolve(img);
      };
      img.onerror = () => {
        this.loading.delete(src);
        reject(new Error(`Failed to load: ${src}`));
      };
      img.src = src;
    });
    
    this.loading.set(src, promise);
    return promise;
  }
  
  getImage(src: string): HTMLImageElement | null {
    return this.loaded.get(src) || null;
  }
}

üîß PHASE 4: MISSING CORE FEATURES IMPLEMENTATION
STEP 9: Implement Jump/Dodge Mechanics
typescript// ADD MISSING JUMP/DODGE:
class PlayerController {
  private jumpVelocity = 0;
  private isJumping = false;
  private canDodge = true;
  private dodgeTimer = 0;
  
  update(deltaTime: number) {
    this.handleInput();
    this.updatePhysics(deltaTime);
  }
  
  private handleInput() {
    // Jump (Spacebar)
    if (Input.isPressed('Space') && !this.isJumping) {
      this.jump();
    }
    
    // Dodge (Shift)
    if (Input.isPressed('Shift') && this.canDodge) {
      this.dodge();
    }
    
    // Basic movement
    if (Input.isDown('ArrowLeft')) this.moveLeft();
    if (Input.isDown('ArrowRight')) this.moveRight();
  }
  
  private jump() {
    this.jumpVelocity = -300; // Pixels per second upward
    this.isJumping = true;
  }
  
  private dodge() {
    this.canDodge = false;
    this.dodgeTimer = 500; // 500ms cooldown
    // Add brief invincibility and movement boost
    player.invincible = true;
    setTimeout(() => player.invincible = false, 300);
  }
  
  private updatePhysics(deltaTime: number) {
    if (this.isJumping) {
      player.y += this.jumpVelocity * (deltaTime / 1000);
      this.jumpVelocity += 800 * (deltaTime / 1000); // Gravity
      
      // Land
      if (player.y >= player.groundY) {
        player.y = player.groundY;
        this.isJumping = false;
        this.jumpVelocity = 0;
      }
    }
    
    // Dodge cooldown
    if (!this.canDodge) {
      this.dodgeTimer -= deltaTime;
      if (this.dodgeTimer <= 0) {
        this.canDodge = true;
      }
    }
  }
}
STEP 10: Implement Basic Weapon System
typescript// SIMPLE RAY GUN IMPLEMENTATION:
class WeaponSystem {
  private rayGunUnlocked = false;
  private projectiles: Projectile[] = [];
  
  update(deltaTime: number) {
    if (Input.isPressed('Space') && this.rayGunUnlocked) {
      this.fireRayGun();
    }
    
    this.updateProjectiles(deltaTime);
  }
  
  unlockRayGun() {
    this.rayGunUnlocked = true;
    console.log('Ray Gun unlocked!');
  }
  
  private fireRayGun() {
    const projectile = new Projectile({
      x: player.x + player.width / 2,
      y: player.y + player.height / 2,
      velocityX: 400, // Pixels per second
      velocityY: 0,
      damage: 1,
      maxHits: 3
    });
    
    this.projectiles.push(projectile);
  }
  
  private updateProjectiles(deltaTime: number) {
    for (let i = this.projectiles.length - 1; i >= 0; i--) {
      const projectile = this.projectiles[i];
      projectile.update(deltaTime);
      
      // Remove if off screen
      if (projectile.x > canvas.width || projectile.hits >= projectile.maxHits) {
        this.projectiles.splice(i, 1);
      }
    }
  }
  
  render() {
    this.projectiles.forEach(projectile => {
      ctx.fillStyle = '#00FF00';
      ctx.fillRect(projectile.x, projectile.y, 4, 2);
    });
  }
}

class Projectile {
  constructor(public config: {
    x: number, y: number, 
    velocityX: number, velocityY: number,
    damage: number, maxHits: number
  }) {}
  
  public x = this.config.x;
  public y = this.config.y;
  public hits = 0;
  
  update(deltaTime: number) {
    this.x += this.config.velocityX * (deltaTime / 1000);
    this.y += this.config.velocityY * (deltaTime / 1000);
  }
}

üìä VALIDATION PROTOCOL
IMMEDIATE SUCCESS METRICS:
typescript// IMPLEMENT PERFORMANCE MONITORING:
class PerformanceValidator {
  validate(): boolean {
    const avgFPS = this.calculateAverageFPS();
    const memoryUsage = (performance as any).memory?.usedJSHeapSize || 0;
    
    console.log(`Performance Check:
      FPS: ${avgFPS.toFixed(1)} (target: 60)
      Memory: ${(memoryUsage / 1024 / 1024).toFixed(1)}MB
      Render Time: ${this.lastRenderTime.toFixed(2)}ms
    `);
    
    return avgFPS >= 55 && this.lastRenderTime < 16;
  }
}

üö® IMPLEMENTATION SEQUENCE (DO NOT DEVIATE)

STEP 1-3: Emergency rendering fixes (MUST achieve 45+ FPS)
STEP 4-6: Performance optimization (MUST achieve 55+ FPS)
STEP 7-8: System reconstruction (MUST achieve 60 FPS)
STEP 9-10: Missing features (maintain 60 FPS)

CRITICAL: Report FPS after each step. If any step doesn't improve performance, STOP and debug that specific step before proceeding.
SUCCESS CRITERIA:

‚úÖ Consistent 60 FPS
‚úÖ No rendering pipeline failures
‚úÖ Jump/dodge mechanics working
‚úÖ Basic weapon system functional
‚úÖ No performance degradation under load

DO NOT implement Pinterest aesthetics until ALL above criteria are met.